#ifndef SINGLECHAINMCMC_H
#define SINGLECHAINMCMC_H

#include "MUQ/SamplingAlgorithms/AbstractSamplingProblem.h"
#include "MUQ/SamplingAlgorithms/TransitionKernel.h"
#include "MUQ/SamplingAlgorithms/ThinScheduler.h"
#include "MUQ/SamplingAlgorithms/MarkovChain.h"

#include <vector>

#include <boost/property_tree/ptree.hpp>

namespace muq{
  namespace SamplingAlgorithms{

    /** @ingroup MCMC
        @class SingleChainMCMC
        @brief Defines an MCMC sampler with a single chain
        @details
        <B>Configuration Parameters:</B>
        Parameter Key | Type | Default Value | Description |
        ------------- | ------------- | ------------- | ------------- |
        "NumSamples"  | Int | - | The total number of steps (including burnin) to take, i.e., the length of the Markov chain. |
        "BurnIn"      | Int | 0 | The number of steps at the beginning of the chain to ignore. |
        "PrintLevel"  | Int | 3 | The amount of information to print to std::cout. Valid values are in [0,1,2,3] with  0 = Nothing, 3 = The most |
        "KernelList"  | String | - | A comma separated list of other parameter blocks that define the transition kernels for each Metropolis-in-Gibbs block. |
    */
    class SingleChainMCMC
    {

    public:

#if MUQ_HAS_PARCER
      SingleChainMCMC(boost::property_tree::ptree pt,
                      std::shared_ptr<parcer::Communicator> const& comm,
                      std::vector<std::shared_ptr<TransitionKernel> > const& kernelsIn);

      SingleChainMCMC(boost::property_tree::ptree pt,
                      std::shared_ptr<AbstractSamplingProblem> const& problem,
                      std::shared_ptr<parcer::Communicator> const& comm);
#endif

      SingleChainMCMC(boost::property_tree::ptree pt,
                      std::shared_ptr<AbstractSamplingProblem> const& problem);

      SingleChainMCMC(boost::property_tree::ptree pt,
                      std::vector<std::shared_ptr<TransitionKernel> > const& kernels);

      SingleChainMCMC(boost::property_tree::ptree pt, 
                      std::shared_ptr<TransitionKernel> const& kernel) : SingleChainMCMC(pt, std::vector<std::shared_ptr<TransitionKernel>>(1,kernel)){};
                      
      virtual ~SingleChainMCMC() = default;
        
      /// Set the state of the MCMC chain
      /**
        If no steps have been taken, this function sets the starting point.
        Set the current state AND adds it to the sample collection.
      */
      virtual void SetState(std::shared_ptr<SamplingState> const& x0);
      virtual void SetState(std::vector<Eigen::VectorXd> const& x0);

      template<typename... Args>
      inline void SetState(Args const&... args) {
        std::vector<Eigen::VectorXd> vec;
        SetStateRecurse(vec, args...);
      }

      virtual std::vector<std::shared_ptr<TransitionKernel>>& Kernels(){return kernels;};

      template<typename... Args>
      inline std::shared_ptr<MarkovChain> Run(Args const&... args) {
        std::vector<Eigen::VectorXd> vec;
        return RunRecurse(vec, args...);
      }

      virtual std::shared_ptr<MarkovChain> Run(std::vector<Eigen::VectorXd> const& x0);

      virtual double TotalTime() { return totalTime; }

      /** When the Run method is called, the Sample() method is called until the
          total number of samples generated by this class is equal to a private
          member variable `numSamps`.   `numSamps` is generally set in the
          options passed to the constructor.  In order to generate more samples
          after an initial call to `Run`, the numSamps variables needs to be
          increasd.  This function essentially sets numSamps=numSamps+numNewSamps.

          Typical usage will be something like:
          @code{.cpp}
          std::shared_ptr<SampleCollection> samps = mcmc->Run(startPt);
          for(unsigned int batchInd=1; batchInd<numBatches; ++batchInd){
            mcmc->AddNumSamps(batchSizes);
            mcmc->Run();
          }
          @endcode


          @param[in] numNewSamps The number of new samples we want to add to numSamps.
                                 After calling this function, the next call to Run
                                 will add an additional numNewSamps to the SampleCollection.


      */
      virtual void AddNumSamps(unsigned int numNewSamps){numSamps+=numNewSamps;};

      /** Returns the current value of the private numSamps variable.  When `Run`
          is called, it calls the `Sample` function until this number of samples
          has been generated.  Note  that unless numSamps is updated by calling
          AddNumSamps, subsequent calls to Run will produce any new samples.
      */
      virtual unsigned int NumSamps() const{return numSamps;};

      void PrintStatus(std::string prefix) const;

      /** Returns the samples generated by the algorithm so far. */
      virtual std::shared_ptr<MarkovChain> GetSamples() const;

      /** Returns the Quantities of Interest (if any) computed so far. */
      std::shared_ptr<MarkovChain> GetQOIs() const;

#if MUQ_HAS_PARCER
      std::shared_ptr<parcer::Communicator> GetCommunicator() const;
#endif

    protected:

      virtual void Sample();

      std::shared_ptr<SamplingState> SaveSamples(std::vector<std::shared_ptr<SamplingState> > const& newStates,
                                                 std::shared_ptr<SamplingState>                    & lastSavedState,
                                                 unsigned int                                      & sampNum) const;

      bool ShouldSave(unsigned int const sampNum) const;

      void PrintStatus(unsigned int currInd) const{PrintStatus("",currInd);};
      void PrintStatus(std::string prefix, unsigned int currInd) const;

      // Samples and quantities of interest will be stored in the MarkovChain class
      std::shared_ptr<MarkovChain> samples;
      std::shared_ptr<MarkovChain> QOIs;

      std::shared_ptr<SaveSchedulerBase> scheduler;
      std::shared_ptr<SaveSchedulerBase> schedulerQOI;

      unsigned int numSamps;
      unsigned int burnIn;
      unsigned int printLevel;

      // A vector of transition kernels: One for each block
      std::vector<std::shared_ptr<TransitionKernel>> kernels;

    private:

#if MUQ_HAS_PARCER
      std::shared_ptr<parcer::Communicator> comm = nullptr;
#endif

      template<typename... Args>
      inline std::shared_ptr<MarkovChain> RunRecurse(std::vector<Eigen::VectorXd>& vec, Eigen::VectorXd const& ith, Args const&... args) {
        vec.push_back(ith);
        return RunRecurse(vec, args...);
      }

      inline std::shared_ptr<MarkovChain> RunRecurse(std::vector<Eigen::VectorXd>& vec, Eigen::VectorXd const& last) {
        vec.push_back(last);
        return Run(vec);
      }

      inline std::shared_ptr<MarkovChain> RunRecurse(std::vector<Eigen::VectorXd>& vec) {
        return Run(vec);
      }
      
      template<typename... Args>
      inline void SetStateRecurse(std::vector<Eigen::VectorXd>& vec, Eigen::VectorXd const& it, Args const&... args) {
        vec.push_back(it);
        SetStateRecurse(vec, args...);
      }

      inline void SetStateRecurse(std::vector<Eigen::VectorXd>& vec, Eigen::VectorXd const& last) {
        vec.push_back(last);
        SetState(vec);
      }

      unsigned int sampNum = 1;
      std::shared_ptr<SamplingState> prevState = nullptr;
      std::shared_ptr<SamplingState> lastSavedState = nullptr;
      double totalTime = 0.0;

      void Setup(boost::property_tree::ptree pt,
                 std::vector<std::shared_ptr<TransitionKernel>> const& kernelsIn);

      void Setup(boost::property_tree::ptree pt, std::shared_ptr<AbstractSamplingProblem> const& problem);

    }; // class SingleChainMCMC
  } // namespace SamplingAlgorithms
} // namespace muq

#endif // #ifndef SINGLECHAINMCMC_H
